package Trees;

import java.util.ArrayList;

public class AVLTree implements ITree<AVLNode> {
	
	private AVLNode root = null;
	private ArrayList<AVLNode> nodes = new ArrayList<>();

	public AVLTree() {}	
	
	@Override
	public Result<AVLNode> insert(int value) {
		if (root == null) {
			root = new AVLNode(value);
			nodes.add(root);
			return null;
		}
		Result<AVLNode> result = search(value);
	    Side side = result.getSide(); //ovìøíme poslední stranu
	    AVLNode parent = (AVLNode) result.getNode();  // vrátí prvek (side = null) nebo rodièe a místo kam uložit (side = R, L)
	    
	    if (side == Side.LEFT) {
	    	parent.setLeftWithGraphic(new AVLNode(value, parent, side));
	    	result.setNode(parent.getLeft()); //zmìním výsledek z rodièe na nový node
	    } else if (side == Side.RIGHT) {
	    	parent.setRightWithGraphic(new AVLNode(value, parent, side));
	    	result.setNode(parent.getRight());
	    } else {
	    	result.setNode(null); //už je obsažen  
	    	return result;
	    }
	    nodes.add((AVLNode)result.getNode());
	    result.addAnimation(AnimatedAction.INSERT, null, null);
	    return balanceTree(result);
	}
    
    @Override
	public Result<AVLNode> delete(int value) {
    	AVLNode removedNode, helpNode = null;
        
        Result<AVLNode> result = search(value);
        Side side = result.getSide(); //zjistím smìr
        removedNode = (AVLNode) result.getNode();

        if (side != Side.NONE) {  //pokud ho nenajdu TODO
            return result;
        }

		if ((removedNode.getLeft() != null) && (removedNode.getRight() != null)) { // pokud má dva potomnky 1.
			helpNode = removedNode.getRight(); // dosadím pravého

			if (helpNode.getLeft() != null || helpNode.getRight() != null) { //pokud dosazovaný má potomky 1.1
				if (helpNode.getLeft() != null) { // pokud pravý potomek nemá levého 1.2
					while (helpNode.getLeft() != null) { // dokud nemám poslední levý 1.3
						helpNode = helpNode.getLeft();
					}					
				}
			}             
            
            removedNode.setValue(helpNode.getValue()); //uložím jeho hodnotu do toho co mažu
            
            result.addAnimation(AnimatedAction.DELETE, null, true);            
            
            if (helpNode.getRight() == null) { //0.1
            	if (helpNode.getGraphicNode().getSide() == Side.RIGHT) { //0.1.1
            		helpNode.getParent().deleteRightWithGraphic();
            		System.out.println("\n0.1.1\n");
            	} else { //0.1.2
            		helpNode.getParent().deleteLeftWithGraphic(); 
            		System.out.println("\n0.1.2\n");
            	}
                
                result.addAnimation(AnimatedAction.MOVENODE, removedNode.getGraphicNode(), helpNode.getGraphicNode()); 
                removedNode.setGraphicNode(helpNode.getGraphicNode());
                
            } else { //0.2
            	if (helpNode.getGraphicNode().getSide() == Side.RIGHT) { //0.2.1
            		helpNode.getParent().setRightWithGraphic(helpNode.getRight());
            	} else { //0.2.2
            		helpNode.getParent().setLeftWithGraphic(helpNode.getRight());  //nebo dosadím místo nìho jeho pravého
            	}
            	
            	result.addAnimation(AnimatedAction.MOVEVALUE, result.getNode().getGraphicNode(), helpNode.getGraphicNode());
            	result.addAnimation(AnimatedAction.MOVENODE, helpNode.getGraphicNode(), helpNode.getRight().getGraphicNode());
            }
        } else if (removedNode.getLeft() != null) {   //zjistím jakého potomka má mazaný  2.
        	result.addAnimation(AnimatedAction.DELETE, null, true);
            result.addAnimation(AnimatedAction.MOVENODE, result.getNode().getGraphicNode(), removedNode.getLeft().getGraphicNode());
            
            removedNode.setNodeWithGraphic(removedNode.getLeft());            
        } else if (removedNode.getRight() != null) { // 3.
        	result.addAnimation(AnimatedAction.DELETE, null, true);
            result.addAnimation(AnimatedAction.MOVENODE, result.getNode().getGraphicNode(), removedNode.getRight().getGraphicNode());
            
            removedNode.setNodeWithGraphic(removedNode.getRight());  
        } else { // 4.   
        	result.addAnimation(AnimatedAction.DELETE, null, false); //pokud nemá dìti 
            if (removedNode.getGraphicNode().getSide() == Side.LEFT) { //nemá žádného potomka, tak je to list => smažu ho
                removedNode.getParent().deleteLeftWithGraphic();               
            } else if (removedNode.equals(root)) { //osamocený root
            	root = null;
            } else {
            	removedNode.getParent().deleteRightWithGraphic();  //pravý            	
            }
            return result; 
        } 
        
        return result;
	}	
	
	/**
	 * @param value - hledaný list
	 * @return ResultNode<AVLNode> - vrací nalezený list (side = NONE) nebo vrací rodièe a stranu
	 * 
	 */
	@Override
    public Result<AVLNode> search(int value) {
		Result<AVLNode> resultNode = new Result<>(root);
		AVLNode result = root;
		AVLNode parent = root;

        while (result != null) {
            if (value < result.getValue()) {
            	parent = result;
                result = result.getLeft();
                
                resultNode.setSide(Side.LEFT); 
            } else if (value > result.getValue()) {
            	parent = result;
            	result = result.getRight();
            	
            	resultNode.setSide(Side.RIGHT); 
            } else {               
            	resultNode.setSide(Side.NONE);
            	resultNode.addSide(result.getGraphicNode());
                break;
            }            
            
            resultNode.addSide(parent.getGraphicNode());
        }
      
        if (resultNode.getSide() == Side.NONE) {
        	resultNode.addAnimation(AnimatedAction.SEARCH, result.getGraphicNode(), true);
        	resultNode.setNode(result);
        } else {
        	resultNode.addAnimation(AnimatedAction.SEARCH, parent.getGraphicNode(), false);
        	resultNode.setNode(parent);
        }
        return resultNode;
    }
	
	/**
	 * Zavolá funkci pro ohodnocení listù a pøípadnì pøidá akce pro balancování stromu
	 * @param result
	 * @return
	 */
	private Result<AVLNode> balanceTree(Result<AVLNode> result) {
		root.countFactor();
		
		AVLNode balanceNode = null;
		
		for (AVLNode node : nodes) {
			if (node.getFactor() == 2 || node.getFactor() == -2) {
				balanceNode = node;
				break;
			}
		}
		
		if (balanceNode != null) {
			if (balanceNode.getFactor() == 2) {
				if (balanceNode.getLeft().getFactor() == -1) {
					return rlBalance();
				} else {
					return rrBalance();
				}
			} else {
				if (balanceNode.getRight().getFactor() == 1) {
					return lrBalance();
				} else {
					return llBalance();
				}
			}
		}
		
		return result;		
	}
	
	private Result<AVLNode> llBalance() {
		// TODO Auto-generated method stub
		return null;
	}

	private Result<AVLNode> lrBalance() {
		// TODO Auto-generated method stub
		return null;
	}

	private Result<AVLNode> rrBalance() {
		// TODO Auto-generated method stub
		return null;
	}

	private Result<AVLNode> rlBalance() {
		// TODO Auto-generated method stub
		return null;
	}

	/********************************************************************************************************
	 * GETS & SETS
	 * 
	 *******************************************************************************************************/
	
	@Override
	public AVLNode getRoot() {
		return root;
	}    	
}